% Define the coordinates of the endpoints of the line segment
classdef Drone
    properties
        com, angle
        rot
        m1, m2, x1, y1, z1
        m3, m4, x2, y2, z2
        motor_mass, gravity, moment_of_inertia
        motor_weights, center_mass
        thrusts
        net_forces, net_moments
    end

    methods
        function obj = Drone()
            % Constructon
            obj.com = [0; 0; 0]; % x, y, z
            obj.angle = [0; 0; 0]; % roll, pitch, yaw a, b c
            
            obj.rot = [cos(obj.angle(2))*cos(obj.angle(3)), sin(obj.angle(1))*sin(obj.angle(2))*cos(obj.angle(3)) - cos(obj.angle(1))*sin(obj.angle(3)), cos(obj.angle(1))*sin(obj.angle(2))*cos(obj.angle(3)) + sin(obj.angle(1))*sin(obj.angle(3));
                        cos(obj.angle(2))*sin(obj.angle(3)), sin(obj.angle(1))*sin(obj.angle(2))*sin(obj.angle(3)) + cos(obj.angle(1))*cos(obj.angle(3)), cos(obj.angle(1))*sin(obj.angle(2))*sin(obj.angle(3)) - sin(obj.angle(1))*cos(obj.angle(3));
                        -sin(obj.angle(2)), sin(obj.angle(1))*cos(obj.angle(2)), cos(obj.angle(1))*cos(obj.angle(2))];

            obj.m1 = obj.rot*[0; -0.5; 0] + obj.com;
            obj.m2 = obj.rot*[0; 0.5; 0] + obj.com;
            obj.m3 = obj.rot*[-0.5; 0; 0] + obj.com;
            obj.m4 = obj.rot*[0.5; 0; 0] + obj.com;

            obj.x1 = [obj.m1(1), obj.m2(1)];
            obj.y1 = [obj.m1(2), obj.m2(2)];
            obj.z1 = [obj.m1(3), obj.m2(3)];

            obj.x2 = [obj.m3(1), obj.m4(1)];
            obj.y2 = [obj.m3(2), obj.m4(2)];
            obj.z2 = [obj.m3(3), obj.m4(3)];

            obj.motor_mass = 0.054;
            obj.gravity = 9.81;

            obj.motor_weights = ones(4, 1)*obj.motor_mass*obj.gravity;
            obj.center_mass = 0.1;

            obj.thrusts = zeros(4, 1) + [3; 3; 3; 3];
            obj.net_forces = zeros(3, 1);
            obj.net_forces(3) = (ones(1,4)*obj.motor_weights + obj.center_mass*obj.gravity);
            

        end

        function accel = calc_accel(obj)
            obj.net_forces(3) = (ones(1,4)*obj.motor_weights + obj.center_mass*obj.gravity);
            norm = -cross([obj.x1(2)-obj.x1(1), obj.y1(2)-obj.y1(1), obj.z1(2)-obj.z1(1)], [obj.x2(2)-obj.x2(1), obj.y2(2)-obj.y2(1), obj.z2(2)-obj.z2(1)]);
            net_thrust = ones(1,4)*obj.thrusts;
            obj.net_forces = obj.net_forces + norm*net_thrust;
            accel = obj.net_forces/((obj.center_mass + obj.motor_mass*4)*obj.gravity);
            
        end


        function show_drone(obj)
           
            figure;
            
            h1 = plot3(obj.x1, obj.y1, obj.z1, 'b-', 'LineWidth', 2);
            hold on;
           
          
            % Plot the second line segment
            h2 = plot3(obj.x2, obj.y2, obj.z2, 'r-', 'LineWidth', 2);
            
            hold off;
 
            grid on;

            axis([-10, 10, -10, 10, 0, 20]);

            numSteps = 100;

            % Animation loop
            for step = 1:numSteps
                % Update coordinates (you can modify this based on your needs)
                accel = obj.calc_accel();
                % set new COM
                del_x = accel(1)*0.5*0.1^2;
                del_y = accel(2)*0.5*0.1^2;
                del_z = accel(3)*0.5*0.1^2;
                obj.com = [obj.com(1) + del_x; obj.com(2) + del_y; obj.com(3) + del_z];
                disp(obj.com);

                %set new angles and rot
                del_roll = 0;
                del_pitch = 0.05;
                del_yaw = 0;
                obj.angle = [obj.angle(1) + del_roll; obj.angle(2) + del_pitch; obj.angle(3) + del_yaw];

                obj.rot = [cos(obj.angle(2))*cos(obj.angle(3)), sin(obj.angle(1))*sin(obj.angle(2))*cos(obj.angle(3)) - cos(obj.angle(1))*sin(obj.angle(3)), cos(obj.angle(1))*sin(obj.angle(2))*cos(obj.angle(3)) + sin(obj.angle(1))*sin(obj.angle(3));
                        cos(obj.angle(2))*sin(obj.angle(3)), sin(obj.angle(1))*sin(obj.angle(2))*sin(obj.angle(3)) + cos(obj.angle(1))*cos(obj.angle(3)), cos(obj.angle(1))*sin(obj.angle(2))*sin(obj.angle(3)) - sin(obj.angle(1))*cos(obj.angle(3));
                        -sin(obj.angle(2)), sin(obj.angle(1))*cos(obj.angle(2)), cos(obj.angle(1))*cos(obj.angle(2))];

            
                obj.m1 = obj.rot*[0; -0.5; 0] + obj.com;
                obj.m2 = obj.rot*[0; 0.5; 0] + obj.com;
                obj.m3 = obj.rot*[-0.5; 0; 0] + obj.com;
                obj.m4 = obj.rot*[0.5; 0; 0] + obj.com;
            
                obj.x1 = [obj.m1(1), obj.m2(1)];
                obj.y1 = [obj.m1(2), obj.m2(2)];
                obj.z1 = [obj.m1(3), obj.m2(3)];
            
                obj.x2 = [obj.m3(1), obj.m4(1)];
                obj.y2 = [obj.m3(2), obj.m4(2)];
                obj.z2 = [obj.m3(3), obj.m4(3)];
            
                % Update line plot data
                set(h1, 'XData', obj.x1, 'YData', obj.y1, 'ZData', obj.z1);
                set(h2, 'XData', obj.x2, 'YData', obj.y2, 'ZData', obj.z2);
            
                % Pause to control the animation speed
                pause(0.1);
                
                % Refresh the figure
                drawnow;
            end            
            xlabel('X-axis');
            ylabel('Y-axis');
            zlabel('Z-axis');
            title('Two 3D Line Segments');
        end

    end
end

