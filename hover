#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <Servo.h>
#include "ppm.h"

#define THROTTLE        2
#define ROLL            3
#define PITCH           4
#define YAW             1
#define SWITCH3WAY_1    5
#define BUTTON          6
#define SWITCH          7
#define POT             8 

const long interval = 50;
unsigned long previousMillis = 0;

bool callib = true;

Servo ESC1;
Servo ESC2;
Servo ESC3;
Servo ESC4;

float xG;
float yG;
float zG;

float prev = 9.81;

//Accelerometer callibration variables
float acc_prev_guessX = 0.3;
float acc_prev_guessY = -0.2;
float acc_prev_guessZ = 1.5;

float acc_meas_biasX = 0;
float acc_meas_biasY = 0;
float acc_meas_biasZ = 0;

float acc_biasX;
float acc_biasY;
float acc_biasZ;

float acc_avgX = 0;
float acc_avgY = 0;
float acc_avgZ = 0;

bool cal = true;

float motor1 = 0;
float motor2 = 0;
float motor3 = 0;
float motor4 = 0;

float data[6];

float time1 = millis()/1000;
float time2 = 0;
float elapsed_time = 0;

float integralX = 0;
float integralY = 0;

float target_x = 0;
float target_y = 0;

float errorX;
float errorY;

float prev_errorX = 0;
float prev_errorY = 0;

bool joy_up = false;
bool joy_down = false;

// bool joy_up = true;
// bool joy_down = true;

Adafruit_MPU6050 mpu;

void setup() {
  Serial.begin(19200);
  mpu.begin();

  // short throttle      =   (-ppm.read_channel(THROTTLE)+1500)/2;
  // short roll          =   (-ppm.read_channel(ROLL)+1500)/2;
  // short pitch         =   (-ppm.read_channel(PITCH)+1500)/2;
  // short yaw           =   (-ppm.read_channel(YAW)+1500)/2;

  short throttle      =   ppm.read_channel(THROTTLE);
  short roll          =   ppm.read_channel(ROLL);
  short pitch         =   ppm.read_channel(PITCH);
  short yaw           =   ppm.read_channel(YAW);


  // Try to initialize!
  if (!mpu.begin()) {
    Serial.println("Failed to find MPU6050 chip");
    while (1) {
      delay(10);
    }
  }
  Serial.println("MPU6050 Found!");
  delay(100);

  ppm.begin(A0, false);

  //callibrate_gyro();

  ESC1.attach(9, 1000, 2000);
  ESC2.attach(5, 1000, 2000);
  ESC3.attach(11, 1000, 2000);
  ESC4.attach(10, 1000, 2000);


  short swtch = ppm.read_channel(SWITCH);
  if(swtch>1500){
    ESC1.write(2000);
    ESC2.write(2000);
    ESC3.write(2000);
    ESC4.write(2000);
  }
}


void loop() {
  short swtch = ppm.read_channel(SWITCH);
  if(swtch>1500){
    if(!joy_up || !joy_down){
      short throttle      =   ppm.read_channel(THROTTLE);
      Serial.print(joy_up);
      Serial.print(" / ");
      Serial.println(joy_down);
      if(throttle > 1900 && !joy_up){
        joy_up = true;

        ESC1.write(2000);
        ESC2.write(2000);
        ESC3.write(2000);
        ESC4.write(2000);
      }
      if(throttle < 1100 && joy_up){
        joy_down = true;

        ESC1.write(1500);
        ESC2.write(1500);
        ESC3.write(1500);
        ESC4.write(1500);
      }
    }

    else{
      unsigned long currentMillis = millis();
      if (currentMillis - previousMillis >= interval) {
        previousMillis = currentMillis;

        // Acquiring all the channels values
        short throttle      =   ppm.read_channel(THROTTLE);
        short roll          =   ppm.read_channel(ROLL);
        short pitch         =   ppm.read_channel(PITCH);
        short yaw           =   ppm.read_channel(YAW);
        short swtch         =   ppm.read_channel(SWITCH);

        /* Get new sensor events with the readings */
        sensors_event_t a, g, temp;
        mpu.getEvent(&a, &g, &temp);

        callibrate_acc(a, g, temp);

        data[0] = a.acceleration.x - acc_biasX;
        data[1] = a.acceleration.y - acc_biasY;
        data[2] = a.acceleration.z - acc_biasZ;

        // Serial.print(sin(data[0]/9.81));
        // Serial.print("/");
        // Serial.print(sin(data[1]/9.81));
        // Serial.print("/");
        // Serial.println(rad2deg(data[2]));

        time2 = millis();
        elapsed_time = time2 - time1;

        errorX = (target_x - sin(data[0]/9.81))*5;
        errorY = (target_y - sin(data[1]/9.81))*5;

        //Serial.println(data[0]);

        motor1 = throttle + PID(1, 3, 1, errorX, prev_errorX, elapsed_time, integralX)-500;
        motor2 = throttle - PID(1, 3, 1, errorX, prev_errorX, elapsed_time, integralX)-500;
        motor3 = throttle + PID(1, 3, 1, errorY, prev_errorY, elapsed_time, integralY)-500;
        motor4 = throttle - PID(1, 3, 1, errorY, prev_errorY, elapsed_time, integralY)-500;

        time1 = time2;
        prev_errorX = errorX;
        prev_errorY = errorY;

        //Serial.println(swtch);
        if(motor1>900 && motor2>900 && motor3>900 && motor4>900){
          Serial.print(motor1);
          Serial.print(" / ");
          Serial.print(motor2);
          Serial.print(" / ");
          Serial.print(motor3);
          Serial.print(" / ");
          Serial.println(motor4);

          ESC1.write(motor1);
          ESC2.write(motor2);
          ESC3.write(motor3);
          ESC4.write(motor4);

        }
        else{
          ESC1.write(1000);
          ESC2.write(1000);
          ESC3.write(1000);
          ESC4.write(1000);
        }


      }
    }
  }
}




//############### HELPER FUNCTIONS #############
void callibrate_acc(sensors_event_t a, sensors_event_t g, sensors_event_t temp){
  mpu.getEvent(&a, &g, &temp);
  if(cal){
    acc_biasX = a.acceleration.x;
    acc_biasY = a.acceleration.y;
    acc_biasZ = a.acceleration.z - 9.81;
    cal = false;
    Serial.println("DONE CALLIBRATING!");
  }
}

// void callibrate_gyro(){
//   for(int i =0;i<1000;i++){
//     Serial.println(i);
//     sensors_event_t a, g, temp;
//     mpu.getEvent(&a, &g, &temp);

//     gyro_meas_biasX = g.gyro.x;
//     gyro_meas_biasY = g.gyro.y;
//     gyro_meas_biasZ = g.gyro.z - 9.81;

//     gyro_biasX = kalman(gyro_meas_biasX, gyro_prev_guessX);
//     gyro_prev_guessX = gyro_biasX;

//     gyro_biasY = kalman(gyro_meas_biasY, gyro_prev_guessY);
//     gyro_prev_guessY = gyro_biasY;

//     gyro_biasZ = kalman(gyro_meas_biasZ, gyro_prev_guessZ);
//     gyro_prev_guessZ = gyro_biasZ;
//   }
// }

float get_angle(float z){
  float angle;
  if(z<=9.81){
    angle = acos(z/9.81);
  }
  else{
    angle = 0;
  }
  return angle;
}


float rad2deg(float rad){
  return rad*(180/3.14);
}

float kalman(float meas, float prev_guess){
  float new_guess = prev_guess + 0.01*(meas-prev_guess);
  return new_guess;
}

float PID(float K1, float K2, float K3, float error, float prev_error, float time, float integral){
  integral += error * time;
  float change = K1 * error + K2 * (error - prev_error)/time + K3 * integral;
  return change;
}
