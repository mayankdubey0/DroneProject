#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Wire.h>
#include <Servo.h>
#include "ppm.h"

#define THROTTLE        3
#define ROLL            1
#define PITCH           2
#define YAW             4
#define SWITCH3WAY_1    5
#define BUTTON          6
#define SWITCH3WAY_2    7
#define POT             8 

const long interval = 50;
unsigned long previousMillis = 0;

bool callib = true;

Servo ESC1;
Servo ESC2;

float xG;
float yG;
float zG;

float prev = 9.81;

//Accelerometer callibration variables
float acc_prev_guessX = 0.3;
float acc_prev_guessY = -0.2;
float acc_prev_guessZ = 1.5;

float acc_meas_biasX = 0;
float acc_meas_biasY = 0;
float acc_meas_biasZ = 0;

float acc_biasX;
float acc_biasY;
float acc_biasZ;

float acc_avgX = 0;
float acc_avgY = 0;
float acc_avgZ = 0;

bool cal = true;

float motor1 = 0;
float motor2 = 0;
float motor3 = 0;
float motor4 = 0;

float data[6];

float time1 = millis()/1000;
float time2 = 0;
float elapsed_time = 0;

Adafruit_MPU6050 mpu;

void setup(void) {
  Serial.begin(19200);
  // Try to initialize!
  if (!mpu.begin()) {
    //Serial.println("Failed to find MPU6050 chip");
    while (1) {
      delay(10);
    }
  }
  //Serial.println("MPU6050 Found!");
  delay(100);

  ESC1.attach(9, 1000, 2000);
  ESC2.attach(10, 1000, 2000);

  ppm.begin(A0, false);

  callibrate_gyro();
}


void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    // Acquiring all the channels values
    short throttle      =   (-ppm.read_channel(THROTTLE)+1500)/2;
    short roll          =   (-ppm.read_channel(ROLL)+1500)/2;
    short pitch         =   (-ppm.read_channel(PITCH)+1500)/2;
    short yaw           =   (-ppm.read_channel(YAW)+1500)/2;

    /* Get new sensor events with the readings */
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    callibrate_acc(a, g, temp);

    data[0] = a.acceleration.x - acc_biasX;
    data[1] = a.acceleration.y - acc_biasY;
    data[2] = a.acceleration.z - acc_biasZ;

    time2 = millis()/1000;
    elapsed_time = time2 - time1;
    gyro_angleX = data[0] * elapsed_time;
    gyro_angleY = data[1] * elapsed_time;
    gyro_angleZ = data[2] * elapsed_time;
    time1 = time2;

    Serial.print(rad2deg(data[0]));
    Serial.print("/");
    Serial.print(rad2deg(data[1]));
    Serial.print("/");
    Serial.println(rad2deg(data[2]));

    

    ESC1.write(throttle);
    ESC2.write(throttle);


  }
}




//############### HELPER FUNCTIONS #############
void callibrate_acc(sensors_event_t a, sensors_event_t g, sensors_event_t temp){
  mpu.getEvent(&a, &g, &temp);
  if(cal){
    acc_biasX = a.acceleration.x;
    acc_biasY = a.acceleration.y;
    acc_biasZ = a.acceleration.z - 9.81;
    cal = false;
  }
}

void callibrate_gyro(){
  for(int i =0;i<1000;i++){
    Serial.println(i);
    sensors_event_t a, g, temp;
    mpu.getEvent(&a, &g, &temp);

    gyro_meas_biasX = g.gyro.x;
    gyro_meas_biasY = g.gyro.y;
    gyro_meas_biasZ = g.gyro.z - 9.81;

    gyro_biasX = kalman(gyro_meas_biasX, gyro_prev_guessX);
    gyro_prev_guessX = gyro_biasX;

    gyro_biasY = kalman(gyro_meas_biasY, gyro_prev_guessY);
    gyro_prev_guessY = gyro_biasY;

    gyro_biasZ = kalman(gyro_meas_biasZ, gyro_prev_guessZ);
    gyro_prev_guessZ = gyro_biasZ;
  }
}

float get_angle(float z){
  float angle;
  if(z<=9.81){
    angle = acos(z/9.81);
  }
  else{
    angle = 0;
  }
  return angle;
}


float rad2deg(float rad){
  return rad*(180/3.14);
}

float kalman(float meas, float prev_guess){
  float new_guess = prev_guess + 0.01*(meas-prev_guess);
  return new_guess;
}

float PID(float K1, , float error, float prev_error, float time){
  float change = error * K + K * (error - prev_error)/time;
  return change;
}
